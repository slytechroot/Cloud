git status
result: (not a git repository)
(because the .git folder is missing)

#in any folder as long as the Git client is installed
git init
(and then normal git commands)

#to add all files
git add . 
git commit
(add message)

git status
(no changes to commit)

git log
(to get the hash of the commit)

git push
(no configured push destination)

git remote add origin git@gitlab.com:sly/test-node-app.git
git status
git push
fatal: The current branch master has no upstream branch.
(repo is connected, branch is Not)

git push --set-upstream origin master
(Branch master setup to track remote branch master from origin)
(branch connected)
(refresh your Gitlab page to see the uploaded info)
- if we deleted the .git folder we wouldn't be connected to the repo anymore, so we'd have to reconnect it)
rm -rf .git
git status
fatal: not a git repository.

#Concept of branching
Master branch is the main branch, created by default when initializing a repo.
Best practice: It's best to create a branch for each feature and each bugfix. 
Developers can commit without worrying to break main branch.
Big feature branches long open, increase the chance of 'merge conflicts'.
With branches, you achieve a stable main (master) branch, which is ready for deployment.
Any branch is based on the master branch. Branch starts from the same codebase.

git branch

(but the local master branch doesn't know about the other branches created in cloud, so we need to update the local info)
git pull

To switch in between branches:
git checkout <branchname>, so:
git checkout bugfix/user-auth
(now we'd get the local branch connected to the remote branch, so every change to the local code, will only affected the branch 'bugfix/user-auth')

#command line to create a new branch
git checkout master
(to get the master branch updates)

#create a branch and connect
git checkout -b feature/database-connection

If you run 'git branch' the remote repo will not know of the local branch created.
git status
ls
nano <file>
git add .
git commit
(type message, save and exit)

git status
git push
(this doesn't work because the remote repo doesn't know about the feature/ branch)

git push --set-upstream origin feature/database-connection

Lots of teams have a master and a develop branch. The Dev branch is the intermediary master. Then their active branches such as features/ and bugfixes/ get merged
into the develop branch (during the spring) and then the develop branch gets merged with the master, at the end of the sprint. 

Only master branches are used for CI-CD (continuous integration and continuous delivery).
Pipeline is triggered whenever feasture/bugfix code is merged into master.
Deploy every single feature/bugfix to the DEV branch. DEV branches also become 'work in progress' branches.

#Merge requests
Best practice: other developer reviews code changes before merging. Master - is stable and ready for production. 
Use cases: big feature, junior developer or expertise in different area. Great chance to learn and grow from each other.
We use pull requests!!!!
You can view these changes and need merging in the GitLab console under Branches, Merge request on the feature/ branches. 

The 2 numbers mean this:
0 1 
0 - there are 0 changes on the master that I need to merge or pull down
1 - there is 1 change on the branch that needs to be merged with the master.

This can all be done through the GitLab GUI online. 

git pull

If you click Merge, your branch will merge with the Master.

##########
Deleting branches <---------------

Leave the branch or delete it.
Delete branch after merging. Create a new branch when needed.
Don't end up with 100s of branches that nobody knows what they are for. 

Delete the branch locally, if you've deleted on the remote online branch, otherwise you still have it locally.
git checkout master
git pull
git branch -d <name-of-branch>
git branch -d feature/database-connection

#########
Rebase <------
- 2 devs are working on the same branch and making changes locally.
- we commit those changes to the branch, but in the remote online repo
- but the local repository doesn't know about those changes, and the local repo of another dev, doesn't know about My changes.

git add . 
git commit -m "adjusted smth again"
git push
Error: (you can't push you changes because there have been other changes push to the remote branch)
- So I need to do a 'git pull' before I do my 'git push'
git pull = git fetch + git merge

git push
( I am pushing 2 commits, one was my commit and the other one was the 'merge commit')

git pull -r
(git pull rebase)
- pulls the changes from the remote branch and sticks our changes on top of that!!!
- there's no merge branch in-between.

#history of the changes
git log

######
Resolving merge conflicts <----------

git add .
git commit -r "adjusted smth in server"
(commited the changes locally)

- go to remote to do changes in online GUI.
- some developers can make changes in 2-3 locations, in the same file and parallel.

git push
(changes are rejected)

git pull -r
(this created a Merge CONFLICT)
YOU must now tell GIT which changes to accept.

We can go in the Editor and find under Git - Resolve Conflicts.

The space in the middle will be the final product and once that's resolved because of the modifications that you think should be there, go back to the 
command prompt and type:
git rebase --continue

- now you can push your changes to remote:
git push

#######
.gitignore (File) <---------------
(Don't track certain files)

- add .gitignore file to your project (root directory)
- to exclude certain folders or files from git to be tracked
- files and folders are specific to your project. Build folders, where compiled code is located, should be excluded.
- open the .gitignore file and exclude:
.idea/*
build/*
node_modules/*

git status
git rm -r --cached .idea

git status
git add .
git commit -m "Added gitignore file"
git push
(to commit)

- check the ONLINE GUI and the .idea folder should be gone.

git rm -r --cached node_modules
git status
git add .
git commit -m "Remove node_modules from repo"
git push

- they stay in the local folder, but they are not tracked by GIT anymore.

###################### 
Git stash <----------
- save work-in-progress changes (stash)

git status
- we need to move to another branch, but I don't want to commit those changes as they are not ready

git checkout master
(error: your local changes to the following files would be overwritten by checkout)
Solution: 'stash' your changes

git stash
git status
git checkout master
(now it changed to the master)
git checkout bufix/user-auth-error
git status
(nothing to commit, working tree clean)

How do we get back our changes?
git stash pop
(and now we are back to our 'stash'ed changes.

Another use case for stashing
- making changes to the current branch
- notice that something isn't working anymore
(Did I break it with my changes?)
- so hide changes temporarily away to test if it works without my code changes
- bring changes back to my local working directory
git stash pop

####### 
Going back in history <-------
git checkout <commit hash>

History:
git log
- notice the commit hashes

Each commit:
Unique commit hash, commit message, author+date.

A developer notices that after a certain date, an error in the code appears and wants to go back in time to troubleshoot. He'll need to use the commit hash for that!!!
This means we can go back to a specific project version.

git checkout <commit-hash>
git status
git stash
(saved working directory and index state WIP on bugfix/user-auth-error...)

git checkout <commit-hash>
(You are in 'detached HEAD' state.)
- this tells me I am somewhere in the commit stage, but not in the main most up-to-date commit stage of the branch.
- Now that we are in a commit, we can create a branch from here to troubleshoot further.
- Not the most commong scenario that you make changes in the previous state of the application/code.
- Mostly used for testing or resolving a bug

git checkout bugfix/user-auth-error

##########
Undoing commits <----------
git reset --hard (and --soft)
git revert

Changing commits <-------
git commit --amend

git commit -m "removed some log lines"
- if we want to revert the commit to let's say 2
git log
git reset --hard HEAD~2
git log
(we will see that the log commit is gone)

- and we want to go one step back
git log
git reset --hard HEAD~1
git log
git status
(your branch is up to date)
git add .
git commit -m "removed some long lines again"
git log

- so let's say I still want to do some changes and re-commit, remember I've already commited the code.
git reset --soft HEAD~1
or
git reset HEAD~1

git status
(the change is there, but the commit is there)
- this can be tested with making some changes to the code.
git log
git add .
git commit -m "recommiting the changes"

- instead of creating a new commit, it changes the last commit by merging this commit into the last commited.
git add .
git commit --amend
git log
git status
git push

- but let's say I've realized I should have not done the last commit, but the change is already in GitLab, so I want to undo the commit in the remote repository
as well.
git reset --hard HEAD~1
(this will help me start from scratch)
- so I've removed the commit from the local repo, but the remote repo still has it.
git push --force
(--force because we have reverted something, but the remote repo doesn't know this)
- if you refreshed the page, you will see the last Commit is gone from the remote repository.
- DON'T do this in the master branch or the develop branch!!!
- DO THIS ONLY when working alone in a brach!!!!
































































 





































